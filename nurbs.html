<!DOCTYPE html>
<html>
<body>
<canvas id="canvas" width="800" height="600">No &lt;canvas&gt; support</canvas>
<script>"use strict";

function plotFunc(ctx, func, start, end) {
	var step = (end-start)/1000;
	ctx.beginPath();
	ctx.moveTo(0, 600-func(start)*600);
	for (var i = 1; i < 999; i = i+1|0) {
		var v = func(start+step*i);
		ctx.lineTo(.8*i, 600-v*600);
	}
	ctx.lineTo(800, 600-func(end)*600);
	ctx.stroke();
}

function lerp(a, b, pos) {
	var dimensions = a.length|0;
	if (dimensions != b.length|0)
		throw "vectors differ in dimension";
	var res = new Array(dimensions);
	var rest = 1-pos;
	for (var i = 0; i < dimensions; i = i+1|0)
		res[i] = rest*a[i] + pos*b[i];
	return res;
}

function deCasteljau(cpoints, pos) {
	var numPoints = (cpoints.length|0)-1|0;
	var res = new Array(numPoints);
	for (var i = 0; i < numPoints; i = i+1|0)
		res[i] = lerp(cpoints[i], cpoints[i+1|0], pos);
	if (numPoints == 1)
		return res[0];
	return deCasteljau(res, pos);
}

function dehomogenize(point) {
	if (!point || !point.length || point.length<2)
		throw "point must be an array of more than one element";
	var dimensions = (point.length|0)-1|0;
	var w = point[dimensions];
	var res = new Array(dimensions);
	for (var i = 0; i < dimensions; i = i+1|0)
		res[i] = point[i]/w;
	return res;
}

function rationalBezier(ctx, cpoints) {
	ctx.beginPath();
	ctx.moveTo.apply(ctx, dehomogenize(cpoints[0]));
	for (var p = 0; p < 1; p += .0001) {
		var pnt = deCasteljau(cpoints, p);
		ctx.lineTo.apply(ctx, dehomogenize(pnt));
	}
	ctx.lineTo.apply(ctx, dehomogenize(cpoints[(cpoints.length|0)-1|0]));
	ctx.stroke();
}

var ctx = document.getElementById('canvas').getContext('2d');

var bezier_circle = [[
	[100,300,1],
	[100,0,1],
	[800,0,2]
],[
	[400,0,1],
	[700,0,1],
	[1400,600,2]
],[
	[700,300,1],
	[700,600,1],
	[800,1200,2]
],[
	[400,600,1],
	[100,600,1],
	[200,600,2]
]];
//for (var i in bezier_circle) rationalBezier(ctx, bezier_circle[i]);

function bSplineBasisFuncs(degree, knotvector) {
	degree = degree|0;
	var len = (knotvector.length|0)-1|0;
	var res = new Array(len);
	
	if (degree == 0) {
		var len = (knotvector.length|0)-1|0;
		var res = new Array(len);
		for (var i = 0; i < len; i = i+1|0)
			res[i] = function(start,end){return function(x){
				return x>=start && x<end ? 1 : 0;
			};}(knotvector[i],knotvector[i+1|0]);
		return res;
	}
	var subFuncs = bSplineBasisFuncs(degree-1|0, knotvector);
	len = (subFuncs.length|0)-1|0;
	res = new Array(len);
	for (i = 0; i < len; i = i+1|0)
		res[i] = function(f, g, start, stop1, stop2, end){
			var diff1 = stop2 - start;
			var diff2 = end - stop1;
			if (diff1<=0 && diff2<=0)
				return function(){return 0};
			if (diff1<=0) 
				return function(x){return (end-x)/diff2*g(x);};
			if (diff2<=0)
				return function(x){return (x-start)/diff1*f(x);};
			return function(x){return (end-x)/diff2*g(x) + (x-start)/diff1*f(x);};
		}(subFuncs[i], subFuncs[i+1|0],
		knotvector[i], knotvector[i+1|0], knotvector[i+degree|0], knotvector[(i+degree|0)+1|0]);
	return res;
}

var bspline_circle = [
	[400,0,1],
	[100,0,1],
	[200,600,2],
	[100,600,1],
	[400,600,1],
	[700,600,1],
	[1400,600,2],
	[700,0,1],
	[400,0,1]
];
var circle_knots = [0,0,0,.25,.25,.5,.5,.75,.75,1,1,1];
var nurbsbook_knots = [0,0,0,1,2,3,4,4,5,5,5];
var bezier2_knots = [0,0,0,1,1,1];

var bfuncs = bSplineBasisFuncs(2, bezier2_knots);
console.log(bfuncs);
for (var i in bfuncs)
	plotFunc(ctx, bfuncs[i], 0, 1);

function bSpline(ctx, degree, cpoints, knotvector) {
	var bFuncs = bSplineBasisFuncs(degree, knotvector);
	ctx.beginPath();
	var numPoints = cpoints.length|0;
	var len = bFuncs.length|0;
	if (numPoints != bFuncs.length)
		throw null;
	ctx.moveTo.apply(ctx, dehomogenize(cpoints[0]));
	var end = knotvector[(knotvector.length|0)-1|0];
	var step = (end-knotvector[0])/100;
	for (var u = knotvector[0]+step; u < end; u += step) {
		var x = 0, y = 0, w = 0;
		for (var i = 0; i < numPoints; i = i+1|0) {
			var point = cpoints[i];
			if (point.length != 3)
				throw null;
			var weight = bFuncs[i](u);
			x += weight*point[0];
			y += weight*point[1];
			w += weight*point[2];
		}
		ctx.lineTo(x/w,y/w);
	}
	ctx.lineTo.apply(ctx, dehomogenize(cpoints[numPoints-1|0]));
	ctx.stroke();
}

var weight = Math.sqrt(2)/2;

bSpline(ctx, 2, bspline_circle, circle_knots);
</script>
</body>
</html>